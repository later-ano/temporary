var $1662971556 = require('brisky-struct')
;var $826337949 = require('stamp')
;

const $1094503762_next = typeof window === 'undefined'
  ? process.nextTick
  : global.requestAnimationFrame

const $1094503762_serialize = (hub, t, struct, val, level) => {
  if (!struct.isHub || struct.key === 'clients' || (struct._p && struct._p.key === 'clients')) {
    return
  }

  const path = struct.path() // cached version (later)
  const len = path.length

  if (struct.val !== void 0 || val === null) {
    var s = t[0] || (t[0] = {})

    for (let i = level; i < len; i++) {
      let t = s[path[i]]
      if (!t) {
        s = s[path[i]] = {}
      } else {
        s = t
        if (s.val === null) { return }
      }
    }

    s.stamp = struct.stamp

    if (val === null) {
      for (let key in s) {
        if (key !== 'stamp') {
          delete s[key]
        }
      }
      s.val = null
    } else if (struct.val && struct.val.inherits) {
      s.val = struct.val.path()
      s.val.unshift('@', 'root')
      $1094503762_serialize(hub, t, struct.val, val, level)
    } else if (struct.val !== void 0) {
      s.val = struct.val
    }
  }
}

const $1094503762_meta = (hub, subsOnly) => {
  if (!hub.receiveOnly) {
    const store = $1094503762_inProgress(hub, $826337949.inProgress ? $826337949.on : $1094503762_next)
    if (!subsOnly) {
      let keys = hub.client.keys()
      if (keys) {
        let i = keys.length
        while (i--) {
          hub.client.forEach((val, key) => {
            if (
              key !== 'device' &&
              key !== 'ua' &&
              key !== 'platform' &&
              key !== 'browser' &&
              key !== 'version' &&
              key !== 'prefix' &&
              key !== 'webview'
            ) {
              $1094503762_serialize(hub, store, val, void 0, hub.urlIndex)
            }
          })
        }
      }
    }

    if (!store[1]) store[1] = {}

    if (hub.context && !subsOnly) {
      if (hub.context.keys().length > 0) {
        store[1].context = hub.context.compute() ? hub.context.serialize() : false
      } else {
        store[1].context = hub.context.compute() || false
      }
    }
    store[1].id = hub.client.key
    if (hub.upstreamSubscriptions) {
      store[1].s = Object.keys(hub.upstreamSubscriptions)
    }
  } else if (hub.upstreamSubscriptions) {
    let override
    for (let key in hub.upstreamSubscriptions) {
      if (hub.upstreamSubscriptions[key].__force__) {
        if (!override) override = []
        override.push(key)
      }
    }
    if (override) {
      const store = $1094503762_inProgress(hub, $826337949.inProgress ? $826337949.on : $1094503762_next)
      if (!store[1]) store[1] = {}
      const obj = {}
      let i = override.length
      while (i--) {
        obj[override[i]] = hub.upstreamSubscriptions[override[i]]
      }
      store[1].s = Object.keys(obj)
    }
  }
}

const $1094503762_send = (val, stamp, struct) => {
  // also check for removal
  if (
    // (
    //   typeof val === 'object' && val &&
    //   val[0] === void 0 && val.val === void 0
    // ) ||
    (stamp < 0 && val === null && struct.parent(t => {
      if (t.key === 'clients') {
        return true
      }
    }))
  ) {
    return
  }
  let hub
  let p = struct
  while (p) {
    if (p._url_ && !p._c) hub = p
    p = p.parent() // needs to walk over context (for multi server)
  }

  if (hub) {
    if (!hub.receiveOnly) {
      if (struct === hub) {
        if (val === null) {
          return
        }
      } else if (struct._p.key === 'clients') {
        if (struct.key !== hub.client.key) {
          return
        }
      }
      $1094503762_serialize(hub, $1094503762_inProgress(hub, $826337949.on), struct, val, hub.urlIndex)
    }
  }
}

// need to know if created by myself
// else starts correcting wrong stamps
const $1094503762_applyDifference = (val, diff) => {
  for (let key in val) {
    if (typeof val[key] === 'object') {
      $1094503762_applyDifference(val[key], diff)
    } else if (key === 'stamp') {
      val[key] = val[key] + diff
    }
  }
}

const $1094503762_inProgress = (hub, tick) => {
  if (!hub.inProgress) {
    hub.inProgress = []
    tick(() => {
      if (hub.connected.compute() === true) {
        $1094503762_out(hub)
      } else {
        var offset = $826337949.offset
        hub.connected.once(true, () => {
          if ($826337949.offset && Math.abs($826337949.offset - offset) > 1000) {
            $1094503762_applyDifference(hub.inProgress[0], $826337949.offset - offset)
          }
          $1094503762_out(hub)
        })
      }
    })
  }
  return hub.inProgress
}

const $1094503762_out = t => {
  if (!t.socket.send) {
    t.set({ connected: false })
  } else {
    t.socket.send(JSON.stringify(t.inProgress))
  }
  t.inProgress = false
}

const $1094503762_sendSubscriptions = (socket, subs, hub) => {
  let i = subs.length
  const m = {}
  while (i--) {
    const key = subs[i]
    m[key] = hub.upstreamSubscriptions[key]
  }
  const payload = []
  payload[1] = { s: subs, m }
  if (!socket.send) {
    hub.set({ connected: false })
  } else {
    socket.send(JSON.stringify(payload))
  }
}



var $1094503762_$ALL$ = {
  meta: $1094503762_meta,
  send: $1094503762_send,
  sendSubscriptions: $1094503762_sendSubscriptions
}
;var $1939132886 = require('http')
;var $1642042609 = require('events')
;var $197449592_exports = {}
'use strict'

const $197449592_http = $1939132886
const $197449592_EventEmitter = $1642042609
const $197449592_EE_ERROR = 'Registering more than one listener to a WebSocket is not supported.'
const $197449592_DEFAULT_PAYLOAD_LIMIT = 16777216

function $197449592_noop () {}

function $197449592_abortConnection (socket, code, name) {
  socket.end('HTTP/1.1 ' + code + ' ' + name + '\r\n\r\n')
}

function $197449592_emitConnection (ws) {
  this.emit('connection', ws)
}

function $197449592_onServerMessage (message, webSocket) {
  webSocket.internalOnMessage(message)
}

const $197449592_native = (() => {
  try {
    try {
      return process.binding('uws_builtin')
    } catch (e) {
      return require(`./uws_${process.platform}_${process.versions.modules}`)
    }
  } catch (e) {
    console.error(e)
  }
})()

$197449592_native.setNoop($197449592_noop)

var $197449592__upgradeReq = null

const $197449592_clientGroup = $197449592_native.client.group.create(0, $197449592_DEFAULT_PAYLOAD_LIMIT)

$197449592_native.client.group.onConnection($197449592_clientGroup, (external) => {
  const webSocket = $197449592_native.getUserData(external)
  webSocket.external = external
  webSocket.internalOnOpen()
})

$197449592_native.client.group.onMessage($197449592_clientGroup, (message, webSocket) => {
  webSocket.internalOnMessage(message)
})

$197449592_native.client.group.onDisconnection($197449592_clientGroup, (external, code, message, webSocket) => {
  webSocket.external = null

  process.nextTick(() => {
    webSocket.internalOnClose(code, message)
  })

  $197449592_native.clearUserData(external)
})

$197449592_native.client.group.onPing($197449592_clientGroup, (message, webSocket) => {
  webSocket.onping(message)
})

$197449592_native.client.group.onPong($197449592_clientGroup, (message, webSocket) => {
  webSocket.onpong(message)
})

$197449592_native.client.group.onError($197449592_clientGroup, (webSocket) => {
  process.nextTick(() => {
    webSocket.internalOnError({
      message: 'uWs client connection error',
      stack: 'uWs client connection error'
    })
  })
})

class WebSocket {
  constructor (external) {
    this.external = external
    this.internalOnMessage = $197449592_noop
    this.internalOnClose = $197449592_noop
    this.onping = $197449592_noop
    this.onpong = $197449592_noop
  }

  get upgradeReq () {
    return $197449592__upgradeReq
  }

  set onmessage (f) {
    if (f) {
      this.internalOnMessage = (message) => {
        f({data: message})
      }
    } else {
      this.internalOnMessage = $197449592_noop
    }
  }

  set onopen (f) {
    if (f) {
      this.internalOnOpen = f
    } else {
      this.internalOnOpen = $197449592_noop
    }
  }

  set onclose (f) {
    if (f) {
      this.internalOnClose = (code, message) => {
        f({code: code, reason: message})
      }
    } else {
      this.internalOnClose = $197449592_noop
    }
  }

  set onerror (f) {
    if (f && this instanceof WebSocketClient) {
      this.internalOnError = f
    } else {
      this.internalOnError = $197449592_noop
    }
  }

  emit (eventName, arg1, arg2) {
    if (eventName === 'message') {
      this.internalOnMessage(arg1)
    } else if (eventName === 'close') {
      this.internalOnClose(arg1, arg2)
    } else if (eventName === 'ping') {
      this.onping(arg1)
    } else if (eventName === 'pong') {
      this.onpong(arg1)
    }
    return this
  }

  on (eventName, f) {
    if (eventName === 'message') {
      if (this.internalOnMessage !== $197449592_noop) {
        throw Error($197449592_EE_ERROR)
      }
      this.internalOnMessage = f
    } else if (eventName === 'close') {
      if (this.internalOnClose !== $197449592_noop) {
        throw Error($197449592_EE_ERROR)
      }
      this.internalOnClose = f
    } else if (eventName === 'ping') {
      if (this.onping !== $197449592_noop) {
        throw Error($197449592_EE_ERROR)
      }
      this.onping = f
    } else if (eventName === 'pong') {
      if (this.onpong !== $197449592_noop) {
        throw Error($197449592_EE_ERROR)
      }
      this.onpong = f
    } else if (eventName === 'open') {
      if (this.internalOnOpen !== $197449592_noop) {
        throw Error($197449592_EE_ERROR)
      }
      this.internalOnOpen = f
    } else if (eventName === 'error' && this instanceof WebSocketClient) {
      if (this.internalOnError !== $197449592_noop) {
        throw Error($197449592_EE_ERROR)
      }
      this.internalOnError = f
    }
    return this
  }

  once (eventName, f) {
    if (eventName === 'message') {
      if (this.internalOnMessage !== $197449592_noop) {
        throw Error($197449592_EE_ERROR)
      }
      this.internalOnMessage = (message) => {
        this.internalOnMessage = $197449592_noop
        f(message)
      }
    } else if (eventName === 'close') {
      if (this.internalOnClose !== $197449592_noop) {
        throw Error($197449592_EE_ERROR)
      }
      this.internalOnClose = (code, message) => {
        this.internalOnClose = $197449592_noop
        f(code, message)
      }
    } else if (eventName === 'ping') {
      if (this.onping !== $197449592_noop) {
        throw Error($197449592_EE_ERROR)
      }
      this.onping = () => {
        this.onping = $197449592_noop
        f()
      }
    } else if (eventName === 'pong') {
      if (this.onpong !== $197449592_noop) {
        throw Error($197449592_EE_ERROR)
      }
      this.onpong = () => {
        this.onpong = $197449592_noop
        f()
      }
    }
    return this
  }

  removeAllListeners (eventName) {
    if (!eventName || eventName === 'message') {
      this.internalOnMessage = $197449592_noop
    }
    if (!eventName || eventName === 'close') {
      this.internalOnClose = $197449592_noop
    }
    if (!eventName || eventName === 'ping') {
      this.onping = $197449592_noop
    }
    if (!eventName || eventName === 'pong') {
      this.onpong = $197449592_noop
    }
    return this
  }

  removeListener (eventName, cb) {
    if (eventName === 'message' && this.internalOnMessage === cb) {
      this.internalOnMessage = $197449592_noop
    } else if (eventName === 'close' && this.internalOnClose === cb) {
      this.internalOnClose = $197449592_noop
    } else if (eventName === 'ping' && this.onping === cb) {
      this.onping = $197449592_noop
    } else if (eventName === 'pong' && this.onpong === cb) {
      this.onpong = $197449592_noop
    }
    return this
  }

  get OPEN () {
    return WebSocketClient.OPEN
  }

  get CLOSED () {
    return WebSocketClient.CLOSED
  }

  get readyState () {
    return this.external ? WebSocketClient.OPEN : WebSocketClient.CLOSED
  }

  get _socket () {
    const address = this.external ? $197449592_native.getAddress(this.external) : new Array(3)
    return {
      remotePort: address[0],
      remoteAddress: address[1],
      remoteFamily: address[2]
    }
  }

    // from here down, functions are not common between client and server

  ping (message, options, dontFailWhenClosed) {
    if (this.external) {
      $197449592_native.server.send(this.external, message, WebSocketClient.OPCODE_PING)
    }
  }

  terminate () {
    if (this.external) {
      $197449592_native.server.terminate(this.external)
      this.external = null
    }
  }

  send (message, options, cb) {
    if (this.external) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }

      const binary = (options && options.binary) || typeof message !== 'string'

      $197449592_native.server.send(this.external, message, binary ? WebSocketClient.OPCODE_BINARY : WebSocketClient.OPCODE_TEXT, cb ? () => {
        process.nextTick(cb)
      } : undefined)
    } else if (cb) {
      cb(new Error('not opened'))
    }
  }

  close (code, data) {
    if (this.external) {
      $197449592_native.server.close(this.external, code, data)
      this.external = null
    }
  }
}

class WebSocketClient extends WebSocket {
  constructor (uri) {
    super(null)
    this.internalOnOpen = $197449592_noop
    this.internalOnError = $197449592_noop
    $197449592_native.connect($197449592_clientGroup, uri, this)
  }

  ping (message, options, dontFailWhenClosed) {
    if (this.external) {
      $197449592_native.client.send(this.external, message, WebSocketClient.OPCODE_PING)
    }
  }

  terminate () {
    if (this.external) {
      $197449592_native.client.terminate(this.external)
      this.external = null
    }
  }

  send (message, options, cb) {
    if (this.external) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }

      const binary = (options && options.binary) || typeof message !== 'string'

      $197449592_native.client.send(this.external, message, binary ? WebSocketClient.OPCODE_BINARY : WebSocketClient.OPCODE_TEXT, cb ? () => {
        process.nextTick(cb)
      } : undefined)
    } else if (cb) {
      cb(new Error('not opened'))
    }
  }

  close (code, data) {
    if (this.external) {
      $197449592_native.client.close(this.external, code, data)
      this.external = null
    }
  }
}

class Server extends $197449592_EventEmitter {
  constructor (options, callback) {
    super()

    if (!options) {
      throw new TypeError('missing options')
    }

    if (options.port === undefined && !options.server && !options.noServer) {
      throw new TypeError('invalid options')
    }

    var nativeOptions = WebSocketClient.PERMESSAGE_DEFLATE

    if (options.perMessageDeflate !== undefined) {
      if (options.perMessageDeflate === false) {
        nativeOptions = 0
      }
    }

    this.serverGroup = $197449592_native.server.group.create(nativeOptions, options.maxPayload === undefined ? $197449592_DEFAULT_PAYLOAD_LIMIT : options.maxPayload)

        // can these be made private?
    this._upgradeCallback = $197449592_noop
    this._upgradeListener = null
    this._noDelay = options.noDelay === undefined ? true : options.noDelay
    this._lastUpgradeListener = true
    this._passedHttpServer = options.server

    if (!options.noServer) {
      this.httpServer = options.server ? options.server : $197449592_http.createServer((request, response) => {
                // todo: default HTTP response
        response.end()
      })

      if (options.path && (!options.path.length || options.path[0] !== '/')) {
        options.path = '/' + options.path
      }

      this.httpServer.on('upgrade', this._upgradeListener = (request, socket, head) => {
        if (!options.path || options.path === request.url.split('?')[0].split('#')[0]) {
          if (options.verifyClient) {
            const info = {
              origin: request.headers.origin,
              secure: request.connection.authorized !== undefined || request.connection.encrypted !== undefined,
              req: request
            }

            if (options.verifyClient.length === 2) {
              options.verifyClient(info, (result, code, name) => {
                if (result) {
                  this.handleUpgrade(request, socket, head, $197449592_emitConnection)
                } else {
                  $197449592_abortConnection(socket, code, name)
                }
              })
            } else {
              if (options.verifyClient(info)) {
                this.handleUpgrade(request, socket, head, $197449592_emitConnection)
              } else {
                $197449592_abortConnection(socket, 400, 'Client verification failed')
              }
            }
          } else {
            this.handleUpgrade(request, socket, head, $197449592_emitConnection)
          }
        } else {
          if (this._lastUpgradeListener) {
            $197449592_abortConnection(socket, 400, 'URL not supported')
          }
        }
      })

      this.httpServer.on('newListener', (eventName, listener) => {
        if (eventName === 'upgrade') {
          this._lastUpgradeListener = false
        }
      })

      this.httpServer.on('error', (err) => {
        this.emit('error', err)
      })
    }

    $197449592_native.server.group.onDisconnection(this.serverGroup, (external, code, message, webSocket) => {
      webSocket.external = null

      process.nextTick(() => {
        webSocket.internalOnClose(code, message)
      })

      $197449592_native.clearUserData(external)
    })

    $197449592_native.server.group.onMessage(this.serverGroup, $197449592_onServerMessage)

    $197449592_native.server.group.onPing(this.serverGroup, (message, webSocket) => {
      webSocket.onping(message)
    })

    $197449592_native.server.group.onPong(this.serverGroup, (message, webSocket) => {
      webSocket.onpong(message)
    })

    $197449592_native.server.group.onConnection(this.serverGroup, (external) => {
      const webSocket = new WebSocket(external)

      $197449592_native.setUserData(external, webSocket)
      this._upgradeCallback(webSocket)
      $197449592__upgradeReq = null
    })

    if (options.port !== undefined) {
      if (options.host) {
        this.httpServer.listen(options.port, options.host, () => {
          this.emit('listening')
          callback && callback()
        })
      } else {
        this.httpServer.listen(options.port, () => {
          this.emit('listening')
          callback && callback()
        })
      }
    }
  }

  handleUpgrade (request, socket, upgradeHead, callback) {
    const secKey = request.headers['sec-websocket-key']
    if (socket._isNative) {
      if (this.serverGroup) {
        $197449592__upgradeReq = request
        this._upgradeCallback = callback || $197449592_noop
        $197449592_native.upgrade(this.serverGroup, socket.external, secKey, request.headers['sec-websocket-extensions'], request.headers['sec-websocket-protocol'])
      }
    } else {
      const socketHandle = socket.ssl ? socket._parent._handle : socket._handle
      const sslState = socket.ssl ? socket.ssl._external : null
      if (socketHandle && secKey && secKey.length === 24) {
        socket.setNoDelay(this._noDelay)
        const ticket = $197449592_native.transfer(socketHandle.fd === -1 ? socketHandle : socketHandle.fd, sslState)
        socket.on('close', () => {
          if (this.serverGroup) {
            $197449592__upgradeReq = request
            this._upgradeCallback = callback || $197449592_noop
            $197449592_native.upgrade(this.serverGroup, ticket, secKey, request.headers['sec-websocket-extensions'], request.headers['sec-websocket-protocol'])
          }
        })
      }
      socket.destroy()
    }
  }

  broadcast (message, options) {
    if (this.serverGroup) {
      $197449592_native.server.group.broadcast(this.serverGroup, message, (options && options.binary) || false)
    }
  }

  startAutoPing (interval, userMessage) {
    if (this.serverGroup) {
      $197449592_native.server.group.startAutoPing(this.serverGroup, interval, userMessage)
    }
  }

  close (cb) {
    if (this._upgradeListener && this.httpServer) {
      this.httpServer.removeListener('upgrade', this._upgradeListener)

      if (!this._passedHttpServer) {
        this.httpServer.close()
      }
    }

    if (this.serverGroup) {
      $197449592_native.server.group.close(this.serverGroup)
      this.serverGroup = null
    }

    if (typeof cb === 'function') {
      setTimeout(cb, 20000)
    }
  }

  get clients () {
    if (this.serverGroup) {
      return {
        length: $197449592_native.server.group.getSize(this.serverGroup),
        forEach: (cb) => { $197449592_native.server.group.forEach(this.serverGroup, cb) }
      }
    }
  }
}

WebSocketClient.PERMESSAGE_DEFLATE = 1
WebSocketClient.SERVER_NO_CONTEXT_TAKEOVER = 2
WebSocketClient.CLIENT_NO_CONTEXT_TAKEOVER = 4
WebSocketClient.OPCODE_TEXT = 1
WebSocketClient.OPCODE_BINARY = 2
WebSocketClient.OPCODE_PING = 9
WebSocketClient.OPEN = 1
WebSocketClient.CLOSED = 0
WebSocketClient.Server = Server
WebSocketClient.http = $197449592_native.httpServer
WebSocketClient.native = $197449592_native
var $197449592 = WebSocketClient

;
var $1704955210 = $197449592

;const $3851780354_isEmpty = t => {
  for (let i in t) { return false }
  return true
}

const $3851780354_parse = (struct, obj, key, root) => {
  const result = {}
  if (!root) { root = result }
  if (obj.type) result.type = $3851780354_parse(struct, obj.type, 'type')
  for (let i in obj) {
    if (i !== '_' && i !== 'type') {
      if (typeof obj[i] === 'function') {
        let val = obj[i].toString()
        if (!/^(function|\()/.test(val)) {
          // this can all be done on the hub itself of course
          // hash will also be used for sec purposes
          // this will just be send up and done on the hub -- not here!

          if (/^.+=>/.test(val)) {
            if (!/^(\(){0, 1}.+(\)){0, 1} +=>/.test(val)) {
              val = val.replace(/^(.*?)( +=>)/, '($1)$2')
            }
            if (!/^(.*?)+=> +{(.*?)}$/.test(val) && val.indexOf('return ') === -1) {
              val = val.replace(/^(.+=> *?)(.*?)/, '$1 { return $2') + ' }'
            }
            val = val.replace('=>', '')
          }
          val = 'function ' + val
        }
        result['$fn|' + i] = val
        // also here we need to rewrite client to use client id
      } else if (typeof obj[i] !== 'object') {
        result[i] = obj[i]
      } else {
        let parsed = $3851780354_parse(struct, obj[i], i, root)
        if (parsed !== void 0) { result[i] = parsed }
      }
    }
  }
  // if result is empty ignore -- may not be a good idea
  return $3851780354_isEmpty(result) ? void 0 : result
}

var $3851780354 = $3851780354_parse

;var $2180032073 = require('string-hash')
;var $3305006410 = require('vigour-ua')
;
const $1384736615_uniq = process.pid
var $1384736615 = () => $2180032073(`b-${Date.now()}-${(Math.random() * 10000) | 0}-${$1384736615_uniq}`)

;


// this has to go to clients
// maybe rename client to something
var $2828932010 = (t, val, stamp, useragent, id) => {
  if (!id) id = t._uid_ || $1384736615()
  $3305006410(useragent, val)
  val.ua = useragent || false
  t.set({ clients: { [id]: val } }, stamp)
  return t.clients[id]
}

;var $1385737091 = 1e7 // byteLength -- has to be like 10mb

;

const $2003515468_send = (client, payload, next) => {
  client.socket.send(payload)
  process.nextTick(next)
}

const $2003515468_sendLarge = (raw, client) => {
  const size = Buffer.byteLength(raw, 'utf8')
  if (size > $1385737091) {
    if (!client.blobInProgress) {
      client.blobInProgress = []
    }
    console.log('📡 exceeds framelimit - split up', (size / (1024 * 1024)) | 0, 'mb')
    const buf = Buffer.from(raw, 'utf8')
    let i = 0

    const drainInProgress = done => {
      if (client.blobInProgress.length > 0) {
        $2003515468_send(client, client.blobInProgress.shift(), () => drainInProgress(done))
      } else {
        done()
      }
    }

    const next = () => {
      i++
      // make sure you end with an non maxsize buffer (send an empty one if nessecary)
      if (i * $1385737091 <= size) {
        $2003515468_send(client, buf.slice(i * $1385737091, (i + 1) * $1385737091), next)
      } else {
        drainInProgress(() => {
          client.blobInProgress = false
        })
      }
    }

    $2003515468_send(client, buf.slice(i * $1385737091, (i + 1) * $1385737091), next)

    return true
  }
}

var $2003515468_bufferArray = false

const $2003515468_receiveLarge = (data, cb) => {
  if (!$2003515468_bufferArray) $2003515468_bufferArray = []
  $2003515468_bufferArray.push(new Buffer(data).toString('utf8'))
  if (data.byteLength < $1385737091) {
    cb($2003515468_bufferArray.join(''))
    $2003515468_bufferArray = false
  }
}



var $2003515468_$ALL$ = {
  sendLarge: $2003515468_sendLarge,
  receiveLarge: $2003515468_receiveLarge
}
;









// client maybe a confusing name

const $3357289264_isNode = typeof window === 'undefined'

const $3357289264_heartbeatTimeout = 3e3

const $3357289264_next = $3357289264_isNode
  ? fn => setTimeout(fn, 18)
  : global.requestAnimationFrame

const $3357289264_connect = (hub, url, reconnect) => {
  // use outside function non anon since its slower (according to uws)
  const socket = new $1704955210(url)
  const client = hub.client || $2828932010(hub, {}, false)
  // var inProgress, queue
  hub.set({ client }, false)
  hub.reconnect = null

  const close = () => {
    const stamp = $826337949.create()
    if (hub.socket.heartbeat) {
      clearTimeout(hub.socket.heartbeat)
      hub.socket.heartbeat = null
    }
    hub.socket = false
    hub.set({ connected: false }, stamp)
    $826337949.close()
    if (!socket.blockReconnect && hub._url_) {
      reconnect = Math.min((reconnect * 1.5), 2000)
      hub.reconnect = setTimeout($3357289264_connect, reconnect, hub, url, reconnect)
    }
  }

  socket.onclose = close

  socket.onerror = $3357289264_isNode ? close : socket.close.bind(socket)

  socket.onopen = () => {
    hub.socket = socket
    if (hub.emitters && hub.emitters.incoming) {
      $3357289264_enableIncomingListener(socket, hub)
    }
  }

  socket.onmessage = (data) => {
    data = data.data
    if (
      typeof data !== 'string' &&
      (data instanceof ArrayBuffer ||
        (!$3357289264_isNode &&
          ((('Blob' in global) && data instanceof Blob) || // eslint-disable-line
          (('WebkitBlob' in global) && data instanceof WebkitBlob)) // eslint-disable-line
        )
      )
    ) {
      $2003515468_receiveLarge(data, data => {
        data = JSON.parse(data)
        $3357289264_receive(hub, data[0], data[1])
      })
    } else {
      data = JSON.parse(data)
      $3357289264_receive(hub, data[0], data[1])
    }
  }
}

const $3357289264_ownListeners = struct => struct !== $4043401927 && (struct.emitters || ($3357289264_ownListeners(struct.inherits)))

const $3357289264_removePaths = (struct, list, stamp, data) => {
  var keep = true
  const keys = $1662971556.getKeys(struct)
  if (keys) {
    let i = keys.length
    keep = i
    while (i--) {
      if ($3357289264_removePaths(struct.get(keys[i]), list, stamp, data && data[keys[i]])) {
        keep--
      }
    }
  }
  if (struct.val !== void 0) {
    const removeStamp = list[$1662971556.puid(struct)]
    if (removeStamp && removeStamp >= struct.stamp && (!data || data.val === void 0)) {
      if ((keys && keep) || $3357289264_ownListeners(struct)) {
        delete struct.val
        struct.emit('data', null, stamp)
        struct.stamp = 0
      } else {
        struct.set(null, stamp, void 0, true)
        return true
      }
    } else {
      struct.stamp = 0
    }
  } else if (!keep && !$3357289264_ownListeners(struct)) {
    struct.set(null, stamp, void 0, true)
    return true
  } else {
    struct.stamp = 0
  }
}

const $3357289264_heartbeat = hub => {
  const socket = hub.socket
  if (socket) {
    if (socket.heartbeat) {
      clearTimeout(socket.heartbeat)
      socket.heartbeat = null
    }
    socket.send(JSON.stringify([void 0, { heartbeat: true }]))
    socket.heartbeat = setTimeout(() => $3357289264_heartbeat(hub), $3357289264_heartbeatTimeout)
  }
}

// raf
const $3357289264_receive = (hub, data, info) => {
  if (info) {
    if (info.stamp) {
      $826337949.setOffset($826337949.offset + (info.stamp | 0) - ($826337949.create() | 0))
    }
    if (info.requestSubs) {
      $1094503762_sendSubscriptions(hub.socket, info.requestSubs, hub)
    }
    if (info.connect) {
      hub.set({ connected: true }, $826337949.create())
      $1094503762_meta(hub)
      if (info.heartbeat) $3357289264_heartbeat(hub)
      $826337949.close()
    }
    if (info.emit) {
      // emit
      const stamp = $826337949.create()
      for (let event in info.emit) {
        if (event === 'broadcast') {

        } else {
          // hub.emit(event, info.emit[event], stamp)
          // need to choose
          // serialize struct if possible
          if (hub.client) {
            hub.client.emit(event, info.emit[event], stamp, true)
          }
        }
      }

      $826337949.close()
    }
  }

  if (data) {
    $3357289264_next(() => {
      const stamp = $826337949.create()
      if (!hub.receiveOnly) {
        hub.receiveOnly = true
        if (info.remove) {
          $3357289264_removePaths(hub, info.remove, stamp, data)
        }
        hub.set(data, stamp, void 0, !!info.remove)
        hub.receiveOnly = null
      } else {
        if (info.remove) {
          $3357289264_removePaths(hub, info.remove, stamp, data)
        }
        hub.set(data, stamp, void 0, !!info.remove)
      }
      $826337949.close()
    })
  }
}

const $3357289264_removeUrl = hub => {
  hub.url = hub._url_ = hub.urlIndex = null
  hub.emitters.set({ data: { url$: null } }, false)
}

const $3357289264_removeSocket = hub => {
  if (hub.reconnect) {
    clearTimeout(hub.reconnect)
    hub.reconnect = null
  }
  if (hub.socket) {
    hub.socket.blockReconnect = true
    hub.socket.close()
  }
  hub.socket = false
}

const $3357289264_url = (hub, val, key, stamp) => {
  hub.on((val, stamp, t) => {
    if (val === null && !t._c && t === hub) {
      hub.subscriptions = []
      $3357289264_removeUrl(hub)
      $3357289264_removeSocket(hub)
    }
  }, 'url$')
  if (val === void 0) {
    throw Error('setting hub.url to "undefined", are you missing an environment variable?\n' + JSON.stringify(process.env, false, 2))
  }
  if (!val) val = null// -- dont know if this is good but you want to be able to set a url on for example false...
  if ((!hub.url && val) || ((hub.url && hub.url.compute()) !== val)) {
    $3357289264_removeSocket(hub)
    if (!val) {
      hub.set({ connected: false }, stamp)
      hub._url_ = null
      if (hub.url) hub.url.set(val, stamp)
    } else {
      if (!hub.url) {
        $1662971556.create({
          on: {
            data: {
              url: (val, stamp, struct) => {
                val = struct.compute()
                if (val) {
                  hub.set({ connected: false }, stamp)
                  let i = -1
                  if (hub.key) i++
                  hub.parent(() => { i++ })
                  hub.urlIndex = i // use this for checks
                  hub._url_ = val
                  $3357289264_connect(hub, val, 50)
                } else {
                  hub._url_ = null
                }
              }
            }
          }
        }, stamp, $1662971556.struct, hub, key)
      }
      if (/^https?/.test(val)) val = val.replace(/^http/, 'ws')
      hub.url.set(val, stamp)
    }
  }
}

const $3357289264_removeClients = (hub, stamp) => {
  const clients = hub.clients
  if (clients && clients.keys().length > 1) {
    clients.forEach((client, key) => {
      if (
        client.val !== null &&
        client !== hub.client
      ) {
        client.set(null, -stamp)
        delete clients[key]
      }
    })
  }
}

const $3357289264_connectedStruct = $1662971556.create({
  on: {
    data: {
      removeClients: (val, stamp, t) => {
        if (t.compute() === false) {
          $3357289264_removeClients(t._p, stamp)
        }
      }
    }
  }
})

const $3357289264_connected = (hub, val, key, stamp) => {
  if (!hub.connected) {
    $1662971556.create(val, stamp, $3357289264_connectedStruct, hub, key)
  } else {
    hub.connected.set(val, stamp)
  }
}

const $3357289264_contextStruct = $1662971556.struct.create({
  props: {
    default: {
      on: {
        data: {
          updateParent: (val, stamp, t) => {
            t.parent().emit('data', val, stamp)
          }
        }
      }
    }
  }
})

const $3357289264_contextIsNotEqual = (val, context) => {
  if (val && typeof val === 'object') {
    for (let field in val) {
      if (!context[field] || (context[field].compute && context[field].compute()) !== val[field]) {
        return true
      }
    }
  } else {
    return val !== context.compute()
  }
}

const $3357289264_context = (hub, val, key, stamp) => {
  if ((!hub.context && val) || (hub.context && $3357289264_contextIsNotEqual(val, hub.context))) {
    if (!hub.context) {
      $1662971556.create(val, stamp, $3357289264_contextStruct, hub, key)
    } else {
      $3357289264_removeClients(hub, stamp)
      hub.context.set(val, stamp)
    }
    if (hub.connected && hub.connected.compute() === true) $1094503762_meta(hub)
  }
}

const $3357289264_props = {
  reconnect: true,
  socket: true,
  urlIndex: true,
  upstreamSubscriptions: true,
  receiveOnly: true,
  url: $3357289264_url,
  context: $3357289264_context,
  connected: $3357289264_connected
}

const $3357289264_stub = () => {}

const $3357289264_define = {
  subscribe (subs, cb, raw, tree, forceUpstream) {
    if (!raw) subs = $1662971556.parse(subs)
    if (!this.receiveOnly || forceUpstream) {
      const parsed = $3851780354(this, subs)
      if (parsed) {
        if (forceUpstream) {
          parsed.__force__ = true
        }
        // why not keep it stringified? -- saves lots of speed
        const key = $2180032073(JSON.stringify(parsed))
        if (!this.upstreamSubscriptions) {
          this.upstreamSubscriptions = {}
          this.upstreamSubscriptions[key] = parsed
          if (this.url) $1094503762_meta(this, true)
        } else if (!this.upstreamSubscriptions[key]) {
          this.upstreamSubscriptions[key] = parsed
          if (this.url) $1094503762_meta(this, true)
        }
      }
    }
    return $1662971556.subscribe(this, subs, cb || $3357289264_stub, tree)
  }
}

const $3357289264_enableIncomingListener = (socket, hub) => {
  if (!socket.incomingOverride) {
    socket.incomingOverride = true
    const field = typeof window === 'undefined'
      ? 'internalOnMessage'
      : 'onmessage'
    const msg = hub.socket[field]
    socket[field] = (data) => {
      hub.emit('incoming', data)
      msg(data)
    }
  }
}

const $3357289264_on = {
  data: { send: $1094503762_send },
  props: {
    incoming: (t, val, key, stamp) => {
      const hub = t._p
      if (hub.socket) $3357289264_enableIncomingListener(hub.socket, hub)
      return $1662971556.emitterProperty(t, val, key, stamp)
    }
  }
}



var $3357289264_$ALL$ = {
  props: $3357289264_props,
  on: $3357289264_on,
  define: $3357289264_define
}
;var $2549126471 = {
  props: {
    contextKey: true,
    getContext: (t, fn) => {
      t.set({
        define: {
          getContext (key, socket) {
            return fn(key, key => $2549126471_createContext(this, key), this, socket)
          }
        }
      })
    }
  },
  getContext: (key, context) => context(key)
}

const $2549126471_createContext = (hub, val) => {
  var result = $2549126471_find(hub, val)
  if (!result) {
    result = hub.create({ contextKey: val }, false)
  }
  return result
}

const $2549126471_find = (hub, val) => {
  const instances = hub.instances
  if (instances) {
    let i = instances.length
    while (i--) {
      if (instances[i].contextKey === val) return instances[i]
    }
  }
}

;function $4225676736_merge (a, b) {
  for (let i in b) {
    if ((!a[i] || typeof a[i] !== 'object')) {
      a[i] = b[i]
    } else {
      $4225676736_merge(a[i], b[i])
    }
  }
}

var $4225676736 = $4225676736_merge

;

const $2381345089_isFn = /^\$fn\|/
const $2381345089_dummy = () => false

// this will all be done with an ast later!
const $2381345089_clientCheck = /(\.|\[\s*?['"])client[^a-z0-9]/
// const replace
// can also check for dangeorus stuff and maybe even allow some requires
// needs hashing algo

const $2381345089_clientContext = (val, client) => {
  const arrMatches = val.match(/\[\s*?['"]client['"].*?\]/g)
  if (arrMatches) {
    for (let i = 0, len = arrMatches.length; i < len; i++) {
      val = val.replace(/['"]client['"]/, '"clients", "' + client.key + '"')
    }
  }
  const matches = val.match(/\.client[^a-z0-9]/g)
  if (matches) {
    for (let i = 0, len = matches.length; i < len; i++) {
      val = val.replace(matches[i].slice(0, -1), '.clients["' + client.key + '"]')
    }
  }
  return val
}

const $2381345089_parse = (obj, state, key, client) => {
  const result = {}
  for (let i in obj) {
    let block
    if (i === 'client' && (!key || key === 'root' || key === 'parent')) {
      block = true
      let id = client.key // wrong need to get client
      if (!result.clients) { result.clients = {} }
      if (!result.clients[id]) { result.clients[id] = {} }
      $4225676736(result.clients[id], $2381345089_parse(obj.client, i, key, client))
    } else if ($2381345089_isFn.test(i)) {
      let val = obj[i]
      i = i.slice(4)
      // need to fix bublé / babel stuff in these fn creations -- prop need to add buble
      // runtime in a hub, and ast
      // let pass
      try {
        if ($2381345089_clientCheck.test(val)) { // eslint-disable-line
          val = $2381345089_clientContext(val, client)
        }
        obj[i] = new Function('return ' + val)() // eslint-disable-line
        // pass = true
        // do dry run with your own key in a props object
        // 2 options for this ofcourse
        // obj[i](state, {}, {}, i)
        // do we want to test for null / void 0?
      } catch (e) {
        let msg
        // if (!pass) {
        msg = `cannot parse function ${key}.exec\n${val}`
        // } else {
        //   msg = `cannot run function ${key}.exec\n${val}`
        // }
        state.emit('error', new Error(msg))
        obj[i] = $2381345089_dummy
      }
    }
    if (!block && i !== '__force__') {
      if (i === 'clients' && result.clients) {
        $4225676736(result[i], obj[i])
      } else if (typeof obj[i] !== 'object') {
        result[i] = obj[i]
      } else {
        result[i] = $2381345089_parse(obj[i], state, i, client)
      }
    }
  }

  return result
}

var $2381345089 = $2381345089_parse

;

// Get local root
const $2641472318_getRoot = t => {
  while (t._p) {
    t = t._p
  }
  return t
}

const $2641472318_cache = (client, struct, stamp) => {
  if (!client.cache) client.cache = { master: {}, branch: {} }
  const uid = $1662971556.puid(struct)
  if ($2641472318_getRoot(struct).contextKey) {
    delete client.cache.master[uid]
    client.cache.branch[uid] = stamp
  } else {
    delete client.cache.branch[uid]
    client.cache.master[uid] = stamp
  }
}

const $2641472318_isCached = (client, struct, stamp) => client.cache &&
  ($2641472318_getRoot(struct).contextKey ? client.cache.branch[$1662971556.puid(struct)] === stamp
    : client.cache.master[$1662971556.puid(struct)] === stamp)

const $2641472318_reuseCache = (client) => {
  if (!client.cache) return void 0

  return {
    cache: {
      master: client.cache.master,
      branch: {}
    },
    remove: client.cache.branch
  }
}



var $2641472318_$ALL$ = {
  cache: $2641472318_cache,
  isCached: $2641472318_isCached,
  reuseCache: $2641472318_reuseCache
}
;




const $727036942_isEmpty = obj => {
  for (let i in obj) { //eslint-disable-line
    return false
  }
  return true
}

const $727036942_progress = (client) => {
  // remove inprogress if upgrade
  if (!client.inProgress) {
    client.inProgress = [ {}, { stamp: $826337949.create() } ]
    if (client.contextSwitched) {
      client.inProgress[1].remove = client.contextSwitched
      delete client.contextSwitched
    }
    setImmediate(() => {
      if (client.val !== null) {
        const p = client.inProgress[0]
        if (client.inProgress[1].remove || !$727036942_isEmpty(p)) {
          if (p.types) {
            // order hack!
            for (let i in p) {
              // order is still important since setting types after the fact is still broken
              // this will be a big update
              // test if it works now since switch-inheritance update
              if (i === 'types') {
                break
              } else {
                let tmp = p[i]
                delete p[i]
                p[i] = tmp
              }
            }
          }
          const raw = JSON.stringify(client.inProgress)
          if (!$2003515468_sendLarge(raw, client)) {
            if (client.blobInProgress) {
              client.blobInProgress.push(raw)
            } else if (client.socket.OPEN) {
              client.socket.send(raw)
            }
          }
        }
        client.inProgress = false
      }
    }, 10)
  }
  return client.inProgress
}

const $727036942_send = (hub, client, struct, type, subs, tree) => {
  if (struct.isHub && client.val !== null) {
    let isRemoved
    if (type === 'remove') {
      if (!struct._p || !struct._p[struct.key]) isRemoved = true
    } else if (type === 'update' && tree.$t !== struct) {
      if (tree.$t && tree.$t._p && !tree.$t._p[tree.$t.key]) {
        let previous = tree.$t
        let prop = previous
        while (previous) {
          if (previous._p && previous._p[previous.key]) {
            // think of something fast for level...
            $727036942_serialize(client, $727036942_progress(client), subs, prop, $1662971556.get(hub, 'serverIndex'), true)
          }
          prop = previous
          previous = previous._p
        }
      }
    }
    $727036942_serialize(client, $727036942_progress(client), subs, struct, $1662971556.get(hub, 'serverIndex'), isRemoved)
  }
}

const $727036942_serialize = (client, t, subs, struct, level, isRemoved, rc) => {
  if (!struct) {
    // console.log('NO STRUCT FISHY IN SERVER SERIALIZE --- BUG')
    return
  }
  const stamp = $1662971556.get(struct, 'stamp') || 1 // remove the need for this default (feels wrong)
  struct._rc = rc || struct
  const val = isRemoved ? null : $1662971556.getRefVal(struct)
  struct._rc = null

  if (val !== void 0 && stamp && !$2641472318_isCached(client, struct, stamp)) {
    // val === null -- double check if this is necessary
    const path = struct.path()
    const len = path.length
    let s = t[0]
    for (let i = level; i < len; i++) {
      let tt = s[path[i]]
      if (!tt) {
        s = s[path[i]] = {}
      } else {
        s = tt
        if (s.val === null) return
      }
    }

    if (isRemoved) {
      $2641472318_cache(client, struct, stamp)
      s.stamp = stamp
      s.val = val
    } else {
      if (subs.type) {
        const type = $1662971556.get(struct, 'type') // make getType (fast)
        if ($1662971556.getVal(type) !== 'hub') {
          $727036942_serialize(client, t, subs.type, type, level)
        }
      }

      $2641472318_cache(client, struct, stamp)
      s.stamp = stamp
      if (struct.key === 'type') {
        if (val === 'hub') return
        $727036942_serialize(client, t, subs, $1662971556.getType(struct, val), level, false, rc)
        // always need a stamp!
      }

      if (typeof val === 'object' && val !== null && val.inherits) {
        s.val = val.path()
        s.val.unshift('@', 'root')
        $727036942_serialize(client, t, subs, val, level, false, rc)
      } else if (val !== void 0) {
        s.val = val
      }
    }
  } else if (val && typeof val === 'object' && val.inherits && !val.__tmp__) {
    // can send a bit too much data when val: true and overlapping keys
    val.__tmp__ = true
    $727036942_serialize(client, t, subs, val, level, false, rc)
    delete val.__tmp__
  }

  if (subs.val === true && !isRemoved && !struct.__tmp__) {
    struct.__tmp__ = true
    $727036942_deepSerialize($1662971556.getKeys(struct), client, t, subs, struct, level, rc)
    delete struct.__tmp__
  }
}

const $727036942_deepSerialize = (keys, client, t, subs, struct, level, rc) => {
  var type
  if ((type = $1662971556.get(struct, 'type')) && type.compute() !== 'hub') {
    $727036942_serialize(client, t, subs, type, level, false, rc || type._c)
  }
  if (keys) {
    for (let i = 0, len = keys.length; i < len; i++) {
      let prop = $1662971556.get(struct, keys[i])
      if (prop && prop.isHub) {
        $727036942_serialize(client, t, subs, prop, level, false, rc || prop._c)
      }
    }
  }
  if (struct._removed) {
    for (let i = 0, len = struct._removed.length; i < len; i++) {
      let prop = struct._removed[i]
      $727036942_serialize(client, t, subs, prop, level, true, rc || prop._c)
    }
  }
}



var $727036942_$ALL$ = {
  progress: $727036942_progress,
  send: $727036942_send
}
;const $1380346132_removeSubscriptions = (t, id) => {
  if (t.subscriptions) {
    let i = t.subscriptions.length
    while (i--) { // clean this up with unsubscribe in struct
      if (t.subscriptions[i]._uid_ == id) { //eslint-disable-line
        t.subscriptions.splice(i, 1)
      }
    }
  }
}

const $1380346132_removeClient = client => {
  const id = client.key
  client.val = null
  if (client.socket) {
    client.socket.client = null
    client.socket = null
  }
  const t = client.parent(2)
  $1380346132_removeSubscriptions(t, id)
  client.set(null)
}



var $1380346132_$ALL$ = {
  removeSubscriptions: $1380346132_removeSubscriptions,
  removeClient: $1380346132_removeClient
}
;







const $834150420_isEmpty = obj => {
  for (let i in obj) { // eslint-disable-line
    return false
  }
  return true
}

var $834150420 = (hub, socket, data) => {
  const payload = data[0]
  const meta = data[1]
  var client = socket.client

  if (meta) {
    if (client) {
      if ('context' in meta && client.context != meta.context) { // eslint-disable-line
        // this is a context switch
        $834150420_create(hub, socket, meta, payload, client, true)
      } else {
        if (meta.s) {
          hub = client.parent(2)
          if (payload) $834150420_setPayload(hub, payload, client)
          $834150420_incomingSubscriptions(hub, client, meta, client.key)
          $826337949.close()
        }
        if (meta.emit) {
          const stamp = $826337949.create()
          for (let key in meta.emit) {
            hub = client.parent(2)
            if (key === 'broadcast') {
              if (hub.clients) {
                for (let id in meta.emit.broadcast) {
                  if (id === '*') {
                    // handle to all / broadcast to all
                  } else {
                    if (hub.clients[id]) {
                      for (let type in meta.emit.broadcast[id]) {
                        hub.clients[id].emit(type, meta.emit.broadcast[id][type], stamp)
                      }
                    }
                  }
                }
              }
            } else {
              // straight emit on server
              // server.client (if its there)
            }
            $826337949.close()
          }
        }
      }
    } else {
      $834150420_create(hub, socket, meta, payload)
    }
  } else if (client) {
    $834150420_setPayload(client.parent(2), payload, client)
    $826337949.close()
  }
}

const $834150420_addToCache = (client, hub, payload) => {
  if (typeof payload === 'object' && payload) {
    for (let key in payload) {
      if (key !== 'val' && key !== 'stamp') {
        let struct = hub[key]
        if (struct && struct.isHub) {
          $834150420_addToCache(client, hub[key], payload[key])
        }
      }
    }
    if (payload.val !== void 0 && payload.stamp) {
      $2641472318_cache(client, hub, payload.stamp)
    }
  }
}

const $834150420_setPayload = (hub, payload, client) => {
  hub.set(payload, false)
  $834150420_addToCache(client, hub, payload)
}

const $834150420_set = (meta, socket, t, payload, reuse) => {
  const stamp = $826337949.create()
  const id = meta.id
  const context = meta.context
  const client = socket.client = $2828932010(
    t, { socket, context }, stamp, socket.useragent, id
  )
  if (reuse) {
    client.cache = reuse.cache
    if (!$834150420_isEmpty(reuse.remove)) {
      client.contextSwitched = reuse.remove
      $727036942_progress(client)
    }
  }
  if (payload) $834150420_setPayload(t, payload, client)
  if (meta.s) $834150420_incomingSubscriptions(t, client, meta, id)
  $826337949.close()
}

const $834150420_clientSet = (client, meta, socket, t, payload, contextSwitched) => {
  let reuse
  if (client) {
    if (contextSwitched) {
      reuse = $2641472318_reuseCache(client)
    }
    $1380346132_removeClient(client)
  }
  $834150420_set(meta, socket, t, payload, reuse)
}

const $834150420_create = (hub, socket, meta, payload, client, contextSwitched) => {
  const t = meta.context ? hub.getContext(meta.context, socket, client) : hub
  if (!t.inherits && t.then) {
    t.then((t) => {
      if (socket.external !== null) {
        $834150420_clientSet(client, meta, socket, t, payload, contextSwitched)
      } else {
        console.log('⚠️ client discconected when logging in')
      }
    }).catch(err => {
      hub.emit('error', err)
    })
  } else {
    $834150420_clientSet(client, meta, socket, t, payload, contextSwitched)
  }
}

const $834150420_parsed = {}

const $834150420_incomingSubscriptions = (hub, client, meta, id) => {
  if (!client) {
    return // silent gaurd
  }

  const update = (t, type, subs, tree) => {
    $727036942_send(hub, client, t, type, subs, tree)
  }

  if (!client.upstreamSubscriptions) client.upstreamSubscriptions = {}

  if (meta.m) {
    for (let key in meta.m) { $834150420_parsed[key] = meta.m[key] }
  }

  let requestSubs
  let i = meta.s.length
  while (i--) {
    const key = meta.s[i]
    if (!$834150420_parsed[key]) {
      if (!requestSubs) requestSubs = []
      requestSubs.push(key)
    } else {
      const uid = key + '-' + id
      if (!client.upstreamSubscriptions[uid]) {
        const subs = $2381345089($834150420_parsed[key], hub, void 0, client)
        client.upstreamSubscriptions[uid] = subs
        $1662971556.subscribe(hub, subs, update)
        hub.subscriptions[hub.subscriptions.length - 1]._uid_ = id
      }
    }
  }

  if (requestSubs) {
    client.socket.send(JSON.stringify([ void 0, { requestSubs } ]))
  }
}

// this can become super efficient ofc -- replace client in very smart way -- blueprint $CLIENT -- this is the client id
// could even do something like -- update._uid_ use this as a key
// export parsed so we can reset in tests

;

var $4215278899_removedInProgress
const $4215278899_on = {
  data: {
    remove$: (val, stamp, struct) => {
      // just do a diff with the payload rly the best way for now...
      if (val === null && (!struct._c || struct._cLevel === 1)) {
        let p = struct
        let hub
        while (p) {
          if (p.port && !p._c) { hub = p }
          p = p.parent()
        }
        if (hub) {
          // probably not working correctly with context
          const target = struct.parent()
          if (target) {
            if (!target._removed) {
              target._removed = []
              if (!$4215278899_removedInProgress) {
                $4215278899_removedInProgress = []
                $826337949.on(() => {
                  let i = $4215278899_removedInProgress.length
                  while (i--) {
                    delete $4215278899_removedInProgress[i]._removed
                  }
                })
              }
              $4215278899_removedInProgress.push(target)
            }
            target._removed.push(struct)
          }
        }
      }
    }
  }
}

var $4215278899 = $4215278899_on

;var $154467150 = {
  "name": "hub.js",
  "description": "Seamless realtime communcation",
  "version": "0.3.19",
  "main": "dist/index.js",
  "browser": {
    "./dist/index.js": "./dist/index.browser.js",
    "./src/client/uid/index.js": "./src/client/uid/browser.js",
    "./src/server/index.js": "./src/server/browser.js",
    "./src/size/index.js": "./src/size/browser.js",
    "./src/client/websocket/index.js": "./src/client/websocket/browser.js",
    "source-map-support": false
  },
  "scripts": {
    "build": "builder-boy src/index.js dist/index.js -r -t node -t browser && cp src/uws/*.node dist/",
    "watch": "builder-boy src/index.js dist/index.js -w -r -t node -t browser",
    "watch-browser": "builder-boy test/browser/index.js test/browser/dist/index.js -w",
    "dev": "nodemon --watch dist --watch test --watch node_modules --exec 'node test/index.js'",
    "pretest": "npm run build",
    "preversion": "npm run precommit",
    "precommit": "npm run test && standard --fix",
    "version-commit": "npm --no-git-tag-version version $(node -pe \"require('./package.json').version.split('-')[0]\")-$(git log -n 1 --pretty=format:'%H')",
    "publish-branch": "npm run version-commit && npm publish --tag $(git rev-parse --abbrev-ref HEAD | sed 's/\\//-/g')",
    "prepublish": "npm run build",
    "test": "node test/index.js",
    "cover": "nyc npm test",
    "travis": "nyc npm test && nyc report --reporter=text-lcov | coveralls"
  },
  "precommit": "precommit",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vigour-io/hub.js.git"
  },
  "keywords": [
    "websocket",
    "tcp",
    "socket",
    "hub",
    "data structure",
    "vector",
    "functional",
    "memory efficient",
    "subscriptions",
    "realtime"
  ],
  "dependencies": {
    "brisky-struct": "^1.10.3",
    "stamp": "^4.0.2",
    "string-hash": "^1.1.3",
    "vigour-ua": "^3.1.3"
  },
  "nyc": {
    "include": [
      "dist/index.js"
    ],
    "sourceMap": true,
    "instrument": true
  },
  "devDependencies": {
    "builder-boy": "latest",
    "coveralls": "^2.12.0",
    "nodemon": "^1.11.0",
    "nyc": "^10.2.0",
    "pre-commit": "^1.2.2",
    "standard": "^9.0.2",
    "tape": "4.6.3"
  },
  "author": "jim de beer",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/vigour-io/hub.js/issues"
  },
  "homepage": "https://github.com/vigour-io/hub.js#readme",
  "contributors": [
    "Jim de Beer <jim@vigour.io>"
  ]
}

;








const $899748844_Server = $197449592.Server

const $899748844_heartbeatTimeout = 8e3

const $899748844_createServer = (hub, port) => {
  const server = new $899748844_Server({ port })
  const forceHeartbeat = hub._forceHeartbeat_ // for testing
  console.log(`💫 hub listening on ${port} version ${$154467150.version}💫`)
  server.on('connection', socket => {
    socket.useragent = socket.upgradeReq && socket.upgradeReq.headers['user-agent']
    // reuse this parse for client creation
    var isHeartbeat = $3305006410(socket.useragent).platform === 'ios' || forceHeartbeat
    if (isHeartbeat) {
      socket.send(JSON.stringify([void 0, {
        stamp: $826337949.create(),
        connect: true,
        heartbeat: true
      }]))
      socket.on('message', (data) => {
        data = JSON.parse(data)
        if (data) {
          if (data[1] && data[1].heartbeat) {
            clearTimeout(socket.isInvalid)
            socket.isInvalid = setTimeout(() => {
              if (socket.client) $1380346132_removeClient(socket.client)
              socket.isInvalid = null
            }, $899748844_heartbeatTimeout)
          } else {
            $834150420(hub, socket, data)
          }
        }
      })
    } else {
      socket.on('message', (data) => {
        data = JSON.parse(data)
        if (data) $834150420(hub, socket, data)
      })
      socket.send(JSON.stringify([void 0, {
        stamp: $826337949.create(),
        connect: true
      }]))
      socket.on('close', () => {
        if (socket.client && !socket.client.heartbeat) $1380346132_removeClient(socket.client)
      })
    }

    // socket.on('error', () => close()) // need to do something here as well no leaks!
  })

  return server
}

const $899748844_removeServer = hub => {
  const server = hub._server_
  const instances = hub.instances
  $899748844_closeConnections(hub)
  for (let i = 0, len = instances && instances.length; i < len; i++) {
    $899748844_closeConnections(instances[i])
  }

  server.close()
  server.httpServer.close()
  // remove all clients subscriptions
  hub._server_ = null
}

const $899748844_closeConnections = hub => {
  const clients = hub.clients
  const id = hub._uid_ // to exclude the client (not nessecary)
  if (clients) {
    clients.forEach(client => {
      if (client.socket && client.key !== id) {
        client.val = null
        $1380346132_removeSubscriptions(hub, client.key)
        client.socket.close()
      }
    })
  }
}

const $899748844_removePort = hub => {
  hub.port = null
  hub.serverIndex = null
  hub.emitters.set({ data: { port$: null } })
}

const $899748844_port = (hub, val, key, stamp) => {
  // use remove
  hub.on((val, stamp, t) => {
    if (val === null && !t._c && t === hub) {
      $899748844_removeServer(hub)
      $899748844_removePort(hub)
    }
  }, 'port$')
  if (!val) val = null
  if ((!hub.port && val) || (hub.port.compute() !== val)) {
    if (hub._server_) {
      $899748844_removeServer(hub)
    }
    if (!val) {
      if (hub.port) hub.port.set(null, stamp)
      $899748844_removePort(hub)
    } else {
      if (!hub.port) {
        $1662971556.create({
          on: {
            data: {
              port: (val, stamp, struct) => {
                val = struct.compute()
                if (val) {
                  let i = -1
                  if (hub.key) i++
                  hub.parent(() => { i++ })
                  hub.serverIndex = i
                  hub._server_ = $899748844_createServer(hub, val)
                }
              }
            }
          }
        }, stamp, $1662971556.struct, hub, key)
      }
      hub.port.set(val, stamp)
    }
  }
}

const $899748844_props = {
  _server_: true,
  serverIndex: true,
  port: $899748844_port
}

var $899748844 = { props: $899748844_props, on: $4215278899 }

;// add helper for server/client parity
const $3329946989_serializeError = (t, val) => {
   // this can become very nice
  return {
    _$isError: true,
    message: val.message,
    stack: val.stack,
    type: val.type,
    from:
      val.from ||
      (t.root().client && t.root().client.key) ||
      t.root()._uid_ ||
      'server'
  }
}

var $3329946989_$ALL$ = {
  serializeError: $3329946989_serializeError
}
;


const $1432160451_emitClientUpstream = (t, type, val) => {
  if (t.root().client) {
    if (!t.root().socket) {
      console.log('emit: 💗 wait until connected', t.root())
    } else {
      const bc = { [t.key]: {} }
      bc[t.key][type] = val
      t.root().socket.send(JSON.stringify([null, {
        emit: {
          broadcast: bc
        }
      }]))
    }
  }
}

var $1432160451 = {
  types: {
    clients: {
      type: 'struct',
      instances: false,
      props: {
        default: {
          type: 'hub',
          instances: false,
          props: {
            cache: true,
            upstreamSubscriptions: true,
            resolve: true,
            socket: true,
            context: true
          },
          define: {
            // event system
            emit (type, val, stamp, dontSend) {
              let sendval = val
              if (val instanceof Error) {
                sendval = $3329946989_serializeError(this, val)
              } else if (val && typeof val === 'object' && val._$isError) {
                const msg = (val.from ? 'from "' + val.from + '": ' : '') +
                  val.message
                const err = new Error(msg)
                err.from = val.from
                err.type = val.err
                err.stack = val.stack
                val = err
              }
              if (!dontSend) {
                if (this.socket) {
                  this.socket.send(JSON.stringify([null, {
                    emit: { [type]: sendval }
                  }]))
                } else {
                  $1432160451_emitClientUpstream(this, type, sendval)
                }
              }
              if (this.root().client === this) {
                $1662971556.emit(this.root(), type, val, stamp)
              }
              $1662971556.emit(this, type, val, stamp)
            }
          }
        }
      }
    }
  },
  props: {
    clients: (t, val, key, stamp) => {
      if (!t.clients) {
        const clients = $1662971556.getType(t, key)
        t.clients = $1662971556.create(val, stamp, clients, t, key)
      } else {
        $1662971556.set(t.clients, val, stamp)
      }
    }
  },
  define: {
    broadcast (type, val, stamp) {
      const h = this
      if (h.clients) {
        // send all
        h.clients.forEach(client => {
          if (client !== h.client) {
            client.emit(type, val, stamp)
          }
        })
      }
    }
  }
}

;





const $4043401927_types = $1662971556.struct.props.types

const $4043401927_hub = $1662971556.create({
  type: 'hub',
  instances: false,
  define: {
    isHub: true,
    listen (port) {
      this.set({ port })
      return this
    },
    connect (url) {
      this.set({ url })
      return this
    }
  },
  props: {
    default: 'self',
    _uid_: (t, val) => { t.set({ define: { _uid_: val } }) },
    _forceHeartbeat_: true,
    types: $4043401927_types.bind(), // to not interfere with struct type
    type: $1662971556.struct.props.type.bind(),
    client: true
  }
})

$4043401927_hub.props.types.struct = $4043401927_hub.create({
  props: { default: $4043401927_types.struct.props.default.bind() }
}, false)

$4043401927_hub.props.types.struct.props.default.struct = $4043401927_hub.props.type.struct = $4043401927_hub

// make a clients folder (client is pretty un clear now...)
$4043401927_hub.set({
  types: { hub: 'self' },
  inject: [ $1432160451, $899748844, $3357289264_$ALL$, $2549126471 ]
}, false)

$4043401927_hub.types._ks = void 0

var $4043401927 = $4043401927_hub

;
const $3474573222_fn = (val, stamp) => $4043401927.create(val, stamp)
var $3474573222 = $3474573222_fn


module.exports = $3474573222