var $1662971556 = require('brisky-struct')
;var $826337949 = require('stamp')
;

const $1094503762_next = typeof window === 'undefined'
  ? process.nextTick
  : global.requestAnimationFrame

const $1094503762_serialize = (hub, t, struct, val, level) => {
  if (!struct.isHub || struct.key === 'clients' || (struct._p && struct._p.key === 'clients')) {
    return
  }

  const path = struct.path() // cached version (later)
  const len = path.length

  if (struct.val !== void 0 || val === null) {
    var s = t[0] || (t[0] = {})

    for (let i = level; i < len; i++) {
      let t = s[path[i]]
      if (!t) {
        s = s[path[i]] = {}
      } else {
        s = t
        if (s.val === null) { return }
      }
    }

    s.stamp = struct.stamp

    if (val === null) {
      for (let key in s) {
        if (key !== 'stamp') {
          delete s[key]
        }
      }
      s.val = null
    } else if (struct.val && struct.val.inherits) {
      s.val = struct.val.path()
      s.val.unshift('@', 'root')
      $1094503762_serialize(hub, t, struct.val, val, level)
    } else if (struct.val !== void 0) {
      s.val = struct.val
    }
  }
}

const $1094503762_meta = (hub, subsOnly) => {
  if (!hub.receiveOnly) {
    const store = $1094503762_inProgress(hub, $826337949.inProgress ? $826337949.on : $1094503762_next)
    if (!subsOnly) {
      let keys = hub.client.keys()
      if (keys) {
        let i = keys.length
        while (i--) {
          hub.client.forEach((val, key) => {
            if (
              key !== 'device' &&
              key !== 'ua' &&
              key !== 'platform' &&
              key !== 'browser' &&
              key !== 'version' &&
              key !== 'prefix' &&
              key !== 'webview'
            ) {
              $1094503762_serialize(hub, store, val, void 0, hub.urlIndex)
            }
          })
        }
      }
    }

    if (!store[1]) store[1] = {}

    if (hub.context && !subsOnly) {
      if (hub.context.keys().length > 0) {
        store[1].context = hub.context.compute() ? hub.context.serialize() : false
      } else {
        store[1].context = hub.context.compute() || false
      }
    }
    store[1].id = hub.client.key
    if (hub.upstreamSubscriptions) {
      store[1].s = Object.keys(hub.upstreamSubscriptions)
    }
  } else if (hub.upstreamSubscriptions) {
    let override
    for (let key in hub.upstreamSubscriptions) {
      if (hub.upstreamSubscriptions[key].__force__) {
        if (!override) override = []
        override.push(key)
      }
    }
    if (override) {
      const store = $1094503762_inProgress(hub, $826337949.inProgress ? $826337949.on : $1094503762_next)
      if (!store[1]) store[1] = {}
      const obj = {}
      let i = override.length
      while (i--) {
        obj[override[i]] = hub.upstreamSubscriptions[override[i]]
      }
      store[1].s = Object.keys(obj)
    }
  }
}

const $1094503762_send = (val, stamp, struct) => {
  // also check for removal
  if (
    // (
    //   typeof val === 'object' && val &&
    //   val[0] === void 0 && val.val === void 0
    // ) ||
    (stamp < 0 && val === null && struct.parent(t => {
      if (t.key === 'clients') {
        return true
      }
    }))
  ) {
    return
  }
  let hub
  let p = struct
  while (p) {
    if (p._url_ && !p._c) hub = p
    p = p.parent() // needs to walk over context (for multi server)
  }

  if (hub) {
    if (!hub.receiveOnly) {
      if (struct === hub) {
        if (val === null) {
          return
        }
      } else if (struct._p.key === 'clients') {
        if (struct.key !== hub.client.key) {
          return
        }
      }
      $1094503762_serialize(hub, $1094503762_inProgress(hub, $826337949.on), struct, val, hub.urlIndex)
    }
  }
}

// need to know if created by myself
// else starts correcting wrong stamps
const $1094503762_applyDifference = (val, diff) => {
  for (let key in val) {
    if (typeof val[key] === 'object') {
      $1094503762_applyDifference(val[key], diff)
    } else if (key === 'stamp') {
      val[key] = val[key] + diff
    }
  }
}

const $1094503762_inProgress = (hub, tick) => {
  if (!hub.inProgress) {
    hub.inProgress = []
    tick(() => {
      if (hub.connected.compute() === true) {
        $1094503762_out(hub)
      } else {
        var offset = $826337949.offset
        hub.connected.once(true, () => {
          if ($826337949.offset && Math.abs($826337949.offset - offset) > 1000) {
            $1094503762_applyDifference(hub.inProgress[0], $826337949.offset - offset)
          }
          $1094503762_out(hub)
        })
      }
    })
  }
  return hub.inProgress
}

const $1094503762_out = t => {
  if (!t.socket.send) {
    t.set({ connected: false })
  } else {
    t.socket.send(JSON.stringify(t.inProgress))
  }
  t.inProgress = false
}

const $1094503762_sendSubscriptions = (socket, subs, hub) => {
  let i = subs.length
  const m = {}
  while (i--) {
    const key = subs[i]
    m[key] = hub.upstreamSubscriptions[key]
  }
  const payload = []
  payload[1] = { s: subs, m }
  if (!socket.send) {
    hub.set({ connected: false })
  } else {
    socket.send(JSON.stringify(payload))
  }
}



var $1094503762_$ALL$ = {
  meta: $1094503762_meta,
  send: $1094503762_send,
  sendSubscriptions: $1094503762_sendSubscriptions
}
;var $1704955210 = global.WebSocket
// if ! native websocket construct a fallback (can use exception builder)

;const $3851780354_isEmpty = t => {
  for (let i in t) { return false }
  return true
}

const $3851780354_parse = (struct, obj, key, root) => {
  const result = {}
  if (!root) { root = result }
  if (obj.type) result.type = $3851780354_parse(struct, obj.type, 'type')
  for (let i in obj) {
    if (i !== '_' && i !== 'type') {
      if (typeof obj[i] === 'function') {
        let val = obj[i].toString()
        if (!/^(function|\()/.test(val)) {
          // this can all be done on the hub itself of course
          // hash will also be used for sec purposes
          // this will just be send up and done on the hub -- not here!

          if (/^.+=>/.test(val)) {
            if (!/^(\(){0, 1}.+(\)){0, 1} +=>/.test(val)) {
              val = val.replace(/^(.*?)( +=>)/, '($1)$2')
            }
            if (!/^(.*?)+=> +{(.*?)}$/.test(val) && val.indexOf('return ') === -1) {
              val = val.replace(/^(.+=> *?)(.*?)/, '$1 { return $2') + ' }'
            }
            val = val.replace('=>', '')
          }
          val = 'function ' + val
        }
        result['$fn|' + i] = val
        // also here we need to rewrite client to use client id
      } else if (typeof obj[i] !== 'object') {
        result[i] = obj[i]
      } else {
        let parsed = $3851780354_parse(struct, obj[i], i, root)
        if (parsed !== void 0) { result[i] = parsed }
      }
    }
  }
  // if result is empty ignore -- may not be a good idea
  return $3851780354_isEmpty(result) ? void 0 : result
}

var $3851780354 = $3851780354_parse

;var $2180032073 = require('string-hash')
;var $3305006410 = require('vigour-ua')
;
const $1384736615_uniq = global.navigator.userAgent +
  global.navigator.userLanguage +
  global.navigator.language
var $1384736615 = () => $2180032073(`b-${Date.now()}-${(Math.random() * 10000) | 0}-${$1384736615_uniq}`)

;


// this has to go to clients
// maybe rename client to something
var $2828932010 = (t, val, stamp, useragent, id) => {
  if (!id) id = t._uid_ || $1384736615()
  $3305006410(useragent, val)
  val.ua = useragent || false
  t.set({ clients: { [id]: val } }, stamp)
  return t.clients[id]
}

;var $1385737091 = 1e7 // byteLength -- has to be like 10mb

;

// TODO: implement send

var $2003515468_blobArray = false

const $2003515468_receiveLarge = (data, cb) => {
  if (!$2003515468_blobArray) $2003515468_blobArray = []
  $2003515468_blobArray.push(data)

  if (data.size < $1385737091) {
    let i = $2003515468_blobArray.length
    let done = i
    let stringArray = []

    while (i--) {
      const reader = new FileReader() // eslint-disable-line

      const onLoadEnd = ((i, e) => {
        reader.removeEventListener('loadend', onLoadEnd, false)
        if (!e.error) {
          stringArray[i] = reader.result
          if (--done === 0) cb(stringArray.join(''))
        }
      }).bind(null, i)

      reader.addEventListener('loadend', onLoadEnd, false)
      reader.readAsText($2003515468_blobArray[i])
    }

    $2003515468_blobArray = false
  }
}



var $2003515468_$ALL$ = {
  receiveLarge: $2003515468_receiveLarge
}
;









// client maybe a confusing name

const $3357289264_isNode = typeof window === 'undefined'

const $3357289264_heartbeatTimeout = 3e3

const $3357289264_next = $3357289264_isNode
  ? fn => setTimeout(fn, 18)
  : global.requestAnimationFrame

const $3357289264_connect = (hub, url, reconnect) => {
  // use outside function non anon since its slower (according to uws)
  const socket = new $1704955210(url)
  const client = hub.client || $2828932010(hub, {}, false)
  // var inProgress, queue
  hub.set({ client }, false)
  hub.reconnect = null

  const close = () => {
    const stamp = $826337949.create()
    if (hub.socket.heartbeat) {
      clearTimeout(hub.socket.heartbeat)
      hub.socket.heartbeat = null
    }
    hub.socket = false
    hub.set({ connected: false }, stamp)
    $826337949.close()
    if (!socket.blockReconnect && hub._url_) {
      reconnect = Math.min((reconnect * 1.5), 2000)
      hub.reconnect = setTimeout($3357289264_connect, reconnect, hub, url, reconnect)
    }
  }

  socket.onclose = close

  socket.onerror = $3357289264_isNode ? close : socket.close.bind(socket)

  socket.onopen = () => {
    hub.socket = socket
    if (hub.emitters && hub.emitters.incoming) {
      $3357289264_enableIncomingListener(socket, hub)
    }
  }

  socket.onmessage = (data) => {
    data = data.data
    if (
      typeof data !== 'string' &&
      (data instanceof ArrayBuffer ||
        (!$3357289264_isNode &&
          ((('Blob' in global) && data instanceof Blob) || // eslint-disable-line
          (('WebkitBlob' in global) && data instanceof WebkitBlob)) // eslint-disable-line
        )
      )
    ) {
      $2003515468_receiveLarge(data, data => {
        data = JSON.parse(data)
        $3357289264_receive(hub, data[0], data[1])
      })
    } else {
      data = JSON.parse(data)
      $3357289264_receive(hub, data[0], data[1])
    }
  }
}

const $3357289264_ownListeners = struct => struct !== $4043401927 && (struct.emitters || ($3357289264_ownListeners(struct.inherits)))

const $3357289264_removePaths = (struct, list, stamp, data) => {
  var keep = true
  const keys = $1662971556.getKeys(struct)
  if (keys) {
    let i = keys.length
    keep = i
    while (i--) {
      if ($3357289264_removePaths(struct.get(keys[i]), list, stamp, data && data[keys[i]])) {
        keep--
      }
    }
  }
  if (struct.val !== void 0) {
    const removeStamp = list[$1662971556.puid(struct)]
    if (removeStamp && removeStamp >= struct.stamp && (!data || data.val === void 0)) {
      if ((keys && keep) || $3357289264_ownListeners(struct)) {
        delete struct.val
        struct.emit('data', null, stamp)
        struct.stamp = 0
      } else {
        struct.set(null, stamp, void 0, true)
        return true
      }
    } else {
      struct.stamp = 0
    }
  } else if (!keep && !$3357289264_ownListeners(struct)) {
    struct.set(null, stamp, void 0, true)
    return true
  } else {
    struct.stamp = 0
  }
}

const $3357289264_heartbeat = hub => {
  const socket = hub.socket
  if (socket) {
    if (socket.heartbeat) {
      clearTimeout(socket.heartbeat)
      socket.heartbeat = null
    }
    socket.send(JSON.stringify([void 0, { heartbeat: true }]))
    socket.heartbeat = setTimeout(() => $3357289264_heartbeat(hub), $3357289264_heartbeatTimeout)
  }
}

// raf
const $3357289264_receive = (hub, data, info) => {
  if (info) {
    if (info.stamp) {
      $826337949.setOffset($826337949.offset + (info.stamp | 0) - ($826337949.create() | 0))
    }
    if (info.requestSubs) {
      $1094503762_sendSubscriptions(hub.socket, info.requestSubs, hub)
    }
    if (info.connect) {
      hub.set({ connected: true }, $826337949.create())
      $1094503762_meta(hub)
      if (info.heartbeat) $3357289264_heartbeat(hub)
      $826337949.close()
    }
    if (info.emit) {
      // emit
      const stamp = $826337949.create()
      for (let event in info.emit) {
        if (event === 'broadcast') {

        } else {
          // hub.emit(event, info.emit[event], stamp)
          // need to choose
          // serialize struct if possible
          if (hub.client) {
            hub.client.emit(event, info.emit[event], stamp, true)
          }
        }
      }

      $826337949.close()
    }
  }

  if (data) {
    $3357289264_next(() => {
      const stamp = $826337949.create()
      if (!hub.receiveOnly) {
        hub.receiveOnly = true
        if (info.remove) {
          $3357289264_removePaths(hub, info.remove, stamp, data)
        }
        hub.set(data, stamp, void 0, !!info.remove)
        hub.receiveOnly = null
      } else {
        if (info.remove) {
          $3357289264_removePaths(hub, info.remove, stamp, data)
        }
        hub.set(data, stamp, void 0, !!info.remove)
      }
      $826337949.close()
    })
  }
}

const $3357289264_removeUrl = hub => {
  hub.url = hub._url_ = hub.urlIndex = null
  hub.emitters.set({ data: { url$: null } }, false)
}

const $3357289264_removeSocket = hub => {
  if (hub.reconnect) {
    clearTimeout(hub.reconnect)
    hub.reconnect = null
  }
  if (hub.socket) {
    hub.socket.blockReconnect = true
    hub.socket.close()
  }
  hub.socket = false
}

const $3357289264_url = (hub, val, key, stamp) => {
  hub.on((val, stamp, t) => {
    if (val === null && !t._c && t === hub) {
      hub.subscriptions = []
      $3357289264_removeUrl(hub)
      $3357289264_removeSocket(hub)
    }
  }, 'url$')
  if (val === void 0) {
    throw Error('setting hub.url to "undefined", are you missing an environment variable?\n' + JSON.stringify(process.env, false, 2))
  }
  if (!val) val = null// -- dont know if this is good but you want to be able to set a url on for example false...
  if ((!hub.url && val) || ((hub.url && hub.url.compute()) !== val)) {
    $3357289264_removeSocket(hub)
    if (!val) {
      hub.set({ connected: false }, stamp)
      hub._url_ = null
      if (hub.url) hub.url.set(val, stamp)
    } else {
      if (!hub.url) {
        $1662971556.create({
          on: {
            data: {
              url: (val, stamp, struct) => {
                val = struct.compute()
                if (val) {
                  hub.set({ connected: false }, stamp)
                  let i = -1
                  if (hub.key) i++
                  hub.parent(() => { i++ })
                  hub.urlIndex = i // use this for checks
                  hub._url_ = val
                  $3357289264_connect(hub, val, 50)
                } else {
                  hub._url_ = null
                }
              }
            }
          }
        }, stamp, $1662971556.struct, hub, key)
      }
      if (/^https?/.test(val)) val = val.replace(/^http/, 'ws')
      hub.url.set(val, stamp)
    }
  }
}

const $3357289264_removeClients = (hub, stamp) => {
  const clients = hub.clients
  if (clients && clients.keys().length > 1) {
    clients.forEach((client, key) => {
      if (
        client.val !== null &&
        client !== hub.client
      ) {
        client.set(null, -stamp)
        delete clients[key]
      }
    })
  }
}

const $3357289264_connectedStruct = $1662971556.create({
  on: {
    data: {
      removeClients: (val, stamp, t) => {
        if (t.compute() === false) {
          $3357289264_removeClients(t._p, stamp)
        }
      }
    }
  }
})

const $3357289264_connected = (hub, val, key, stamp) => {
  if (!hub.connected) {
    $1662971556.create(val, stamp, $3357289264_connectedStruct, hub, key)
  } else {
    hub.connected.set(val, stamp)
  }
}

const $3357289264_contextStruct = $1662971556.struct.create({
  props: {
    default: {
      on: {
        data: {
          updateParent: (val, stamp, t) => {
            t.parent().emit('data', val, stamp)
          }
        }
      }
    }
  }
})

const $3357289264_contextIsNotEqual = (val, context) => {
  if (val && typeof val === 'object') {
    for (let field in val) {
      if (!context[field] || (context[field].compute && context[field].compute()) !== val[field]) {
        return true
      }
    }
  } else {
    return val !== context.compute()
  }
}

const $3357289264_context = (hub, val, key, stamp) => {
  if ((!hub.context && val) || (hub.context && $3357289264_contextIsNotEqual(val, hub.context))) {
    if (!hub.context) {
      $1662971556.create(val, stamp, $3357289264_contextStruct, hub, key)
    } else {
      $3357289264_removeClients(hub, stamp)
      hub.context.set(val, stamp)
    }
    if (hub.connected && hub.connected.compute() === true) $1094503762_meta(hub)
  }
}

const $3357289264_props = {
  reconnect: true,
  socket: true,
  urlIndex: true,
  upstreamSubscriptions: true,
  receiveOnly: true,
  url: $3357289264_url,
  context: $3357289264_context,
  connected: $3357289264_connected
}

const $3357289264_stub = () => {}

const $3357289264_define = {
  subscribe (subs, cb, raw, tree, forceUpstream) {
    if (!raw) subs = $1662971556.parse(subs)
    if (!this.receiveOnly || forceUpstream) {
      const parsed = $3851780354(this, subs)
      if (parsed) {
        if (forceUpstream) {
          parsed.__force__ = true
        }
        // why not keep it stringified? -- saves lots of speed
        const key = $2180032073(JSON.stringify(parsed))
        if (!this.upstreamSubscriptions) {
          this.upstreamSubscriptions = {}
          this.upstreamSubscriptions[key] = parsed
          if (this.url) $1094503762_meta(this, true)
        } else if (!this.upstreamSubscriptions[key]) {
          this.upstreamSubscriptions[key] = parsed
          if (this.url) $1094503762_meta(this, true)
        }
      }
    }
    return $1662971556.subscribe(this, subs, cb || $3357289264_stub, tree)
  }
}

const $3357289264_enableIncomingListener = (socket, hub) => {
  if (!socket.incomingOverride) {
    socket.incomingOverride = true
    const field = typeof window === 'undefined'
      ? 'internalOnMessage'
      : 'onmessage'
    const msg = hub.socket[field]
    socket[field] = (data) => {
      hub.emit('incoming', data)
      msg(data)
    }
  }
}

const $3357289264_on = {
  data: { send: $1094503762_send },
  props: {
    incoming: (t, val, key, stamp) => {
      const hub = t._p
      if (hub.socket) $3357289264_enableIncomingListener(hub.socket, hub)
      return $1662971556.emitterProperty(t, val, key, stamp)
    }
  }
}



var $3357289264_$ALL$ = {
  props: $3357289264_props,
  on: $3357289264_on,
  define: $3357289264_define
}
;var $2549126471 = {
  props: {
    contextKey: true,
    getContext: (t, fn) => {
      t.set({
        define: {
          getContext (key, socket) {
            return fn(key, key => $2549126471_createContext(this, key), this, socket)
          }
        }
      })
    }
  },
  getContext: (key, context) => context(key)
}

const $2549126471_createContext = (hub, val) => {
  var result = $2549126471_find(hub, val)
  if (!result) {
    result = hub.create({ contextKey: val }, false)
  }
  return result
}

const $2549126471_find = (hub, val) => {
  const instances = hub.instances
  if (instances) {
    let i = instances.length
    while (i--) {
      if (instances[i].contextKey === val) return instances[i]
    }
  }
}

;// no server in the browser -- yet
var $899748844 = {}

;// add helper for server/client parity
const $3329946989_serializeError = (t, val) => {
   // this can become very nice
  return {
    _$isError: true,
    message: val.message,
    stack: val.stack,
    type: val.type,
    from:
      val.from ||
      (t.root().client && t.root().client.key) ||
      t.root()._uid_ ||
      'server'
  }
}

var $3329946989_$ALL$ = {
  serializeError: $3329946989_serializeError
}
;


const $1432160451_emitClientUpstream = (t, type, val) => {
  if (t.root().client) {
    if (!t.root().socket) {
      console.log('emit: 💗 wait until connected', t.root())
    } else {
      const bc = { [t.key]: {} }
      bc[t.key][type] = val
      t.root().socket.send(JSON.stringify([null, {
        emit: {
          broadcast: bc
        }
      }]))
    }
  }
}

var $1432160451 = {
  types: {
    clients: {
      type: 'struct',
      instances: false,
      props: {
        default: {
          type: 'hub',
          instances: false,
          props: {
            cache: true,
            upstreamSubscriptions: true,
            resolve: true,
            socket: true,
            context: true
          },
          define: {
            // event system
            emit (type, val, stamp, dontSend) {
              let sendval = val
              if (val instanceof Error) {
                sendval = $3329946989_serializeError(this, val)
              } else if (val && typeof val === 'object' && val._$isError) {
                const msg = (val.from ? 'from "' + val.from + '": ' : '') +
                  val.message
                const err = new Error(msg)
                err.from = val.from
                err.type = val.err
                err.stack = val.stack
                val = err
              }
              if (!dontSend) {
                if (this.socket) {
                  this.socket.send(JSON.stringify([null, {
                    emit: { [type]: sendval }
                  }]))
                } else {
                  $1432160451_emitClientUpstream(this, type, sendval)
                }
              }
              if (this.root().client === this) {
                $1662971556.emit(this.root(), type, val, stamp)
              }
              $1662971556.emit(this, type, val, stamp)
            }
          }
        }
      }
    }
  },
  props: {
    clients: (t, val, key, stamp) => {
      if (!t.clients) {
        const clients = $1662971556.getType(t, key)
        t.clients = $1662971556.create(val, stamp, clients, t, key)
      } else {
        $1662971556.set(t.clients, val, stamp)
      }
    }
  },
  define: {
    broadcast (type, val, stamp) {
      const h = this
      if (h.clients) {
        // send all
        h.clients.forEach(client => {
          if (client !== h.client) {
            client.emit(type, val, stamp)
          }
        })
      }
    }
  }
}

;





const $4043401927_types = $1662971556.struct.props.types

const $4043401927_hub = $1662971556.create({
  type: 'hub',
  instances: false,
  define: {
    isHub: true,
    listen (port) {
      this.set({ port })
      return this
    },
    connect (url) {
      this.set({ url })
      return this
    }
  },
  props: {
    default: 'self',
    _uid_: (t, val) => { t.set({ define: { _uid_: val } }) },
    _forceHeartbeat_: true,
    types: $4043401927_types.bind(), // to not interfere with struct type
    type: $1662971556.struct.props.type.bind(),
    client: true
  }
})

$4043401927_hub.props.types.struct = $4043401927_hub.create({
  props: { default: $4043401927_types.struct.props.default.bind() }
}, false)

$4043401927_hub.props.types.struct.props.default.struct = $4043401927_hub.props.type.struct = $4043401927_hub

// make a clients folder (client is pretty un clear now...)
$4043401927_hub.set({
  types: { hub: 'self' },
  inject: [ $1432160451, $899748844, $3357289264_$ALL$, $2549126471 ]
}, false)

$4043401927_hub.types._ks = void 0

var $4043401927 = $4043401927_hub

;
const $3474573222_fn = (val, stamp) => $4043401927.create(val, stamp)
var $3474573222 = $3474573222_fn


module.exports = $3474573222